[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Blog Individual ( Juan Mendes )",
    "section": "",
    "text": "Serie historica da cotacao do dolar com Plotly\nMonitoramento em tempo real de frota utilizando Folium e Olho Vivo\nRegressao linear matricial conectando anos de estudo e salario"
  },
  {
    "objectID": "index.html#projeto-de-sistemas-de-informacao-atividades-individuais",
    "href": "index.html#projeto-de-sistemas-de-informacao-atividades-individuais",
    "title": "Blog Individual ( Juan Mendes )",
    "section": "",
    "text": "Serie historica da cotacao do dolar com Plotly\nMonitoramento em tempo real de frota utilizando Folium e Olho Vivo\nRegressao linear matricial conectando anos de estudo e salario"
  },
  {
    "objectID": "index.html#atividade-1-cotacao-do-dolar-por-periodo",
    "href": "index.html#atividade-1-cotacao-do-dolar-por-periodo",
    "title": "Blog Individual ( Juan Mendes )",
    "section": "Atividade 1 – Cotacao do dolar por periodo",
    "text": "Atividade 1 – Cotacao do dolar por periodo\n\nObjetivo: transformar o parametro MMYYYY em datas validas e consumir a API PTAX do Banco Central.\nEntrada: 052014 (maio/2014).\nFerramentas: requests, pandas, plotly.express.\n\n\n\n\n\n\n\nAPI consultada: Cotacao do Dolar por Periodo – PTAX/BCB.\n\n\n\n\n\n\n\n\n\nVisão geral: O trecho consome a API PTAX do Banco Central para coletar as cotações de compra e venda do dólar em um mês especificado e transforma esses dados em um conjunto pronto para análise, visualização e resumo estatístico.\nPreparação da consulta: Define o dicionário com os nomes dos meses em português e dispara as requisições com request_with_retry, que repete a chamada até três vezes em caso de falhas temporárias. A função fetch_dollar_series(periodo) recebe o período no formato mmYYYY, amplia a janela de busca em até sete dias antes do início do mês e monta a URL da API PTAX correspondente.\nProcessamento e saída: Converte a resposta em JSON, normaliza os dados para manter apenas data, cotação de compra e cotação de venda e trata os cenários em que não há registros retornados. Quando há dados, agrupa por dia, completa o calendário diário com forward fill e gera o gráfico Plotly da cotação de venda. Além disso, calcula indicadores como total de observações, maior e menor cotação e as datas correspondentes, resultando em um dataset diário completo, gráfico interativo e breve resumo estatístico.\n\n\n\n\nimport calendar\nfrom datetime import datetime, timedelta\nimport requests\nimport pandas as pd\nimport plotly.express as px\nimport time\nfrom requests.exceptions import RequestException\n\n\nNOMES_MESES = {\n    1: \"Janeiro\",\n    2: \"Fevereiro\",\n    3: \"Marco\",\n    4: \"Abril\",\n    5: \"Maio\",\n    6: \"Junho\",\n    7: \"Julho\",\n    8: \"Agosto\",\n    9: \"Setembro\",\n    10: \"Outubro\",\n    11: \"Novembro\",\n    12: \"Dezembro\",\n}\n\n\ndef request_with_retry(\n    method: str,\n    url: str,\n    *,\n    session: requests.Session | None = None,\n    max_attempts: int = 3,\n    backoff_seconds: int = 2,\n    **kwargs,\n) -&gt; requests.Response | None:\n    \"\"\"Executa requisições HTTP com tentativas extras em caso de falha transitória.\"\"\"\n    for attempt in range(max_attempts):\n        try:\n            requester = session.request if session else requests.request\n            response = requester(method, url, **kwargs)\n            response.raise_for_status()\n            return response\n        except RequestException as exc:\n            if attempt == max_attempts - 1:\n                print(f\"Aviso: falha ao acessar {url} ({exc}).\")\n                return None\n            espera = backoff_seconds * (attempt + 1)\n            print(\n                f\"Aviso: tentativa {attempt + 1} falhou ({exc}). \"\n                f\"Nova tentativa em {espera} s.\"\n            )\n            time.sleep(espera)\n\n\ndef fetch_dollar_series(periodo: str) -&gt; pd.DataFrame:\n    \"\"\"Busca a serie PTAX (cotacao de compra e venda) para o mes informado.\"\"\"\n    data_inicial = datetime.strptime(periodo, \"%m%Y\")\n    data_final = data_inicial.replace(\n        day=calendar.monthrange(data_inicial.year, data_inicial.month)[1]\n    )\n    consulta_inicial = data_inicial - timedelta(days=7)\n    base_url = (\n        \"https://olinda.bcb.gov.br/olinda/servico/PTAX/versao/v1/odata/\"\n        \"CotacaoDolarPeriodo(dataInicial=@dataInicial,dataFinalCotacao=@dataFinalCotacao)\"\n    )\n    query = (\n        f\"{base_url}?@dataInicial='{consulta_inicial.strftime('%m-%d-%Y')}'\"\n        f\"&@dataFinalCotacao='{data_final.strftime('%m-%d-%Y')}'\"\n        \"&$top=1000&$format=json\"\n    )\n    response = request_with_retry(\"GET\", query, timeout=15)\n    if response is None:\n        return pd.DataFrame(columns=[\"data\", \"cotacaoCompra\", \"cotacaoVenda\"])\n    try:\n        payload = response.json()\n    except ValueError as exc:\n        print(f\"Aviso: resposta invalida da API PTAX ({exc}).\")\n        return pd.DataFrame(columns=[\"data\", \"cotacaoCompra\", \"cotacaoVenda\"])\n    valores = payload.get(\"value\", [])\n    if not valores:\n        print(\"Aviso: a API PTAX nao retornou dados para o periodo solicitado.\")\n        return pd.DataFrame(columns=[\"data\", \"cotacaoCompra\", \"cotacaoVenda\"])\n    df = pd.DataFrame(valores)\n    df[\"data\"] = pd.to_datetime(df[\"dataHoraCotacao\"])\n    df = df.sort_values(\"data\")\n    return df[[\"data\", \"cotacaoCompra\", \"cotacaoVenda\"]]\n\n\nperiodo_escolhido = \"052014\"\nmes_referencia = datetime.strptime(periodo_escolhido, \"%m%Y\")\ninicio_mes = mes_referencia.replace(day=1)\nfim_mes = mes_referencia.replace(\n    day=calendar.monthrange(mes_referencia.year, mes_referencia.month)[1]\n)\ninicio_mes_ts = pd.Timestamp(inicio_mes)\nfim_mes_ts = pd.Timestamp(fim_mes)\nrotulo_mes = f\"{NOMES_MESES[mes_referencia.month]}/{mes_referencia.year}\"\ncotacao_df = fetch_dollar_series(periodo_escolhido)\n\nif cotacao_df.empty:\n    fig_cotacao = px.line(\n        title=f\"Cotacao de venda do dolar (PTAX) -- {rotulo_mes} (dados indisponiveis)\"\n    )\n    cotacao_total = 0\n    maior_cotacao = None\n    data_maior = None\n    menor_cotacao = None\n    data_menor = None\nelse:\n    cotacao_df[\"data\"] = cotacao_df[\"data\"].dt.normalize()\n    cotacao_df = (\n        cotacao_df.sort_values(\"data\")\n        .groupby(\"data\", as_index=False)\n        .agg({\"cotacaoCompra\": \"last\", \"cotacaoVenda\": \"last\"})\n    )\n    dados_limpos = cotacao_df[cotacao_df[\"data\"] &lt;= fim_mes_ts]\n    cotacao_mes = dados_limpos[dados_limpos[\"data\"] &gt;= inicio_mes_ts]\n\n    if cotacao_mes.empty:\n        cotacao_df = pd.DataFrame(columns=[\"data\", \"cotacaoCompra\", \"cotacaoVenda\"])\n        fig_cotacao = px.line(\n            title=f\"Cotacao de venda do dolar (PTAX) -- {rotulo_mes} (dados indisponiveis)\"\n        )\n        cotacao_total = 0\n        maior_cotacao = None\n        data_maior = None\n        menor_cotacao = None\n        data_menor = None\n    else:\n        ultimo_dia_util = dados_limpos[dados_limpos[\"data\"] &lt; inicio_mes_ts].tail(1)\n        cotacao_completa = pd.concat(\n            [ultimo_dia_util, cotacao_mes],\n            ignore_index=True,\n        )\n        calendario_para_ffill = pd.date_range(\n            start=min(cotacao_completa[\"data\"].min(), inicio_mes_ts),\n            end=fim_mes_ts,\n            freq=\"D\",\n        )\n        cotacao_df = (\n            cotacao_completa.set_index(\"data\")\n            .reindex(calendario_para_ffill)\n            .ffill()\n            .reset_index()\n            .rename(columns={\"index\": \"data\"})\n        )\n        cotacao_df = cotacao_df[cotacao_df[\"data\"] &gt;= inicio_mes_ts].reset_index(\n            drop=True\n        )\n\n        fig_cotacao = px.line(\n            cotacao_df,\n            x=\"data\",\n            y=\"cotacaoVenda\",\n            markers=True,\n            title=f\"Cotacao de venda do dolar (PTAX) -- {rotulo_mes}\",\n            labels={\"data\": \"Data\", \"cotacaoVenda\": \"Valor (R$)\"},\n        )\n        fig_cotacao.update_layout(yaxis_tickprefix=\"R$ \")\n        cotacao_total = len(cotacao_df)\n        maior_cotacao = cotacao_df[\"cotacaoVenda\"].max()\n        data_maior = cotacao_df.loc[cotacao_df[\"cotacaoVenda\"].idxmax(), \"data\"].date()\n        menor_cotacao = cotacao_df[\"cotacaoVenda\"].min()\n        data_menor = cotacao_df.loc[cotacao_df[\"cotacaoVenda\"].idxmin(), \"data\"].date()\n\n\nPrevia dos dadosGrafico interativo\n\n\n\ncotacao_df.head()\n\n\n\n\n\n\n\n\ndata\ncotacaoCompra\ncotacaoVenda\n\n\n\n\n0\n2014-05-01\n2.2354\n2.2360\n\n\n1\n2014-05-02\n2.2215\n2.2221\n\n\n2\n2014-05-03\n2.2215\n2.2221\n\n\n3\n2014-05-04\n2.2215\n2.2221\n\n\n4\n2014-05-05\n2.2280\n2.2286\n\n\n\n\n\n\n\n\n\n\nfig_cotacao\n\n                            \n                                            \n\n\n\n\n\n\n\n\n\n\n\n\n\n- Observacoes coletadas: 31\n- Maior cotacao de venda: R$ 2.2405 (2014-05-28)\n- Menor cotacao de venda: R$ 2.2101 (2014-05-13)"
  },
  {
    "objectID": "index.html#atividade-2-monitoramento-de-frota-de-onibus",
    "href": "index.html#atividade-2-monitoramento-de-frota-de-onibus",
    "title": "Blog Individual ( Juan Mendes )",
    "section": "Atividade 2 – Monitoramento de frota de onibus",
    "text": "Atividade 2 – Monitoramento de frota de onibus\n\nObjetivo: exibir paradas e veiculos em tempo real na mesma visualizacao.\nLinha monitorada: 8300-10 – Terminal Lapa &lt;-&gt; Terminal Pirituba.\nFerramentas: requests, pandas, folium.\n\n\n\n\n\n\n\nFonte dos dados: API Olho Vivo – SPTrans.\n\n\n\n\n\n\n\n\n\nRegistro na planilha da disciplina: O ID juanmendes.si (coluna A) e a linha 8300-10 (coluna B) já foram lançados na planilha compartilhada da atividade. Esse preenchimento preserva a exclusividade da linha escolhida e evita sobrescrever outros registros.\n\n\n\n\n\n\n\n\n\nConexão e dados: O código utiliza o token da variável de ambiente SPTRANS_TOKEN (com fallback) e autentica na API Olho Vivo antes de buscar a linha 8300-10. Após receber os códigos internos da linha, consulta as paradas e as posições em tempo real, organizando os dados em linhas_df, paradas_df e posicoes_df com as colunas principais.\nResumos tabulares: Cria paradas_resumo e posicoes_resumo para exibição e trata a ausência de dados com mensagens de aviso e DataFrames vazios, garantindo que o dashboard apresente informações consistentes mesmo quando o retorno estiver incompleto.\nMapa e indicadores: Calcula o ponto central com base nas posições mais recentes (ou em fallback), monta o mapa Folium com camadas separadas para paradas (marcadores azuis) e veículos (marcadores vermelhos e ícones de ônibus) e ativa o LayerControl. Ao final, determina total_paradas, veiculos_em_operacao e ultima_atualizacao, entregando um mapa interativo acompanhado de um painel numérico/tabular dos dados da linha.\n\n\n\n\nimport os\nfrom typing import Tuple\n\nimport pandas as pd\nimport requests\nimport folium\n\n\nTOKEN_PADRAO = \"2627f5b82681d40852fc6d0be89d543be4a1c01b71084c0fa53e5ee52889c0f4\"\nSPTRANS_TOKEN = os.environ.get(\"SPTRANS_TOKEN\", TOKEN_PADRAO)\nNUMERO_LINHA = \"8300-10\"  # Term. Lapa &lt;-&gt; Term. Pirituba\n\n\ndef buscar_linhas(sessao: requests.Session, termo: str) -&gt; pd.DataFrame:\n    \"\"\"Retorna os codigos (cl) cadastrados para uma linha informada.\"\"\"\n    if sessao is None:\n        return pd.DataFrame(columns=[\"cl\", \"sl\", \"tp\", \"ts\"])\n    url = f\"http://api.olhovivo.sptrans.com.br/v2.1/Linha/Buscar?termosBusca={termo}\"\n    resposta = request_with_retry(\"GET\", url, session=sessao, timeout=10)\n    if resposta is None:\n        print(\"Aviso: nao foi possivel localizar a linha na API Olho Vivo.\")\n        return pd.DataFrame(columns=[\"cl\", \"sl\", \"tp\", \"ts\"])\n    try:\n        dados = resposta.json()\n    except ValueError as exc:\n        print(f\"Aviso: resposta invalida ao buscar dados da linha ({exc}).\")\n        return pd.DataFrame(columns=[\"cl\", \"sl\", \"tp\", \"ts\"])\n    df = pd.DataFrame(dados)\n    if df.empty:\n        print(\"Aviso: a API nao retornou codigos para a linha informada.\")\n    return df\n\n\ndef autenticar(token: str) -&gt; requests.Session:\n    \"\"\"Cria sessao autenticada na API Olho Vivo.\"\"\"\n    sessao = requests.Session()\n    resposta = request_with_retry(\n        \"POST\",\n        f\"http://api.olhovivo.sptrans.com.br/v2.1/Login/Autenticar?token={token}\",\n        session=sessao,\n        timeout=10,\n    )\n    if resposta is None:\n        print(\"Aviso: autenticacao na API Olho Vivo falhou apos varias tentativas.\")\n        return None\n    if resposta.text.strip().lower() != \"true\":\n        print(\"Aviso: token informado nao foi aceito pela API Olho Vivo.\")\n        return None\n    return sessao\n\n\ndef obter_paradas(sessao: requests.Session, codigo_linha: int) -&gt; pd.DataFrame:\n    \"\"\"Retorna as paradas cadastradas para a linha informada.\"\"\"\n    if sessao is None:\n        return pd.DataFrame(columns=[\"np\", \"ed\", \"py\", \"px\"])\n    url = (\n        \"http://api.olhovivo.sptrans.com.br/v2.1/\"\n        f\"Parada/BuscarParadasPorLinha?codigoLinha={codigo_linha}\"\n    )\n    resposta = request_with_retry(\"GET\", url, session=sessao, timeout=10)\n    if resposta is None:\n        print(\"Aviso: nao foi possivel obter as paradas da linha.\")\n        return pd.DataFrame(columns=[\"np\", \"ed\", \"py\", \"px\"])\n    try:\n        dados = resposta.json()\n    except ValueError as exc:\n        print(f\"Aviso: resposta invalida ao buscar paradas ({exc}).\")\n        return pd.DataFrame(columns=[\"np\", \"ed\", \"py\", \"px\"])\n    df = pd.DataFrame(dados)\n    if df.empty:\n        return pd.DataFrame(columns=[\"np\", \"ed\", \"py\", \"px\"])\n    return df\n\n\ndef obter_posicoes(sessao: requests.Session, codigo_linha: int) -&gt; pd.DataFrame:\n    \"\"\"Obtem as posicoes em tempo real dos veiculos da linha.\"\"\"\n    if sessao is None:\n        return pd.DataFrame(columns=[\"p\", \"ta\", \"py\", \"px\"])\n    url = (\n        \"http://api.olhovivo.sptrans.com.br/v2.1/\"\n        f\"Posicao/Linha?codigoLinha={codigo_linha}\"\n    )\n    resposta = request_with_retry(\"GET\", url, session=sessao, timeout=10)\n    if resposta is None:\n        print(\"Aviso: nao foi possivel obter a posicao em tempo real da linha.\")\n        return pd.DataFrame(columns=[\"p\", \"ta\", \"py\", \"px\"])\n    try:\n        dados = resposta.json()\n    except ValueError as exc:\n        print(f\"Aviso: resposta invalida ao buscar posicoes ({exc}).\")\n        return pd.DataFrame(columns=[\"p\", \"ta\", \"py\", \"px\"])\n    df = pd.DataFrame(dados.get(\"vs\", []))\n    if df.empty:\n        return pd.DataFrame(columns=[\"p\", \"ta\", \"py\", \"px\"])\n    return df\n\n\nsessao = autenticar(SPTRANS_TOKEN)\nlinhas_df = buscar_linhas(sessao, NUMERO_LINHA)\ncodigos_linha = (\n    linhas_df[\"cl\"].dropna().astype(int).unique().tolist()\n    if not linhas_df.empty\n    else []\n)\n\nparadas_df = pd.DataFrame(columns=[\"np\", \"ed\", \"py\", \"px\"])\nif codigos_linha:\n    paradas_lista = [obter_paradas(sessao, codigo) for codigo in codigos_linha]\n    paradas_df = (\n        pd.concat(paradas_lista, ignore_index=True)\n        if paradas_lista\n        else paradas_df\n    )\n    if not paradas_df.empty:\n        paradas_df = paradas_df.drop_duplicates(subset=[\"np\", \"ed\"]).reset_index(\n            drop=True\n        )\nelse:\n    print(\n        \"Aviso: nenhum codigo de linha foi encontrado. \"\n        \"Verifique se o identificador informado esta correto.\"\n    )\n\nposicoes_df = pd.DataFrame(columns=[\"p\", \"ta\", \"py\", \"px\", \"sentido\", \"rota\"])\nif not linhas_df.empty:\n    posicoes_frames = []\n    for _, linha in linhas_df.iterrows():\n        try:\n            codigo_linha = int(linha.get(\"cl\"))\n        except (TypeError, ValueError):\n            continue\n        posicoes = obter_posicoes(sessao, codigo_linha)\n        if posicoes.empty:\n            continue\n        sentido = \"Ida\" if int(linha.get(\"sl\", 0)) == 1 else \"Volta\"\n        origem = (linha.get(\"tp\") or \"\").strip()\n        destino = (linha.get(\"ts\") or \"\").strip()\n        rota = f\"{origem} -&gt; {destino}\" if origem and destino else sentido\n        posicoes = posicoes.assign(sentido=sentido, rota=rota)\n        posicoes_frames.append(posicoes)\n    if posicoes_frames:\n        posicoes_df = pd.concat(posicoes_frames, ignore_index=True)\n        if \"ta\" in posicoes_df.columns:\n            posicoes_df = posicoes_df.sort_values(\"ta\", ascending=False).reset_index(\n                drop=True\n            )\n\nparadas_resumo = paradas_df[[\"np\", \"ed\"]].rename(\n    columns={\"np\": \"Parada\", \"ed\": \"Endereco\"}\n)\n\ncolunas_resumo = [col for col in [\"p\", \"sentido\", \"rota\", \"ta\"] if col in posicoes_df]\nif colunas_resumo:\n    posicoes_resumo = posicoes_df[colunas_resumo].rename(\n        columns={\n            \"p\": \"Prefixo\",\n            \"sentido\": \"Sentido\",\n            \"rota\": \"Rota\",\n            \"ta\": \"Atualizacao (UTC)\",\n        }\n    )\nelse:\n    posicoes_resumo = pd.DataFrame(\n        columns=[\"Prefixo\", \"Sentido\", \"Rota\", \"Atualizacao (UTC)\"]\n    )\n\n\ndef obter_centro_mapa(\n    paradas: pd.DataFrame, posicoes: pd.DataFrame\n) -&gt; Tuple[float, float]:\n    \"\"\"Retorna um ponto central adequado para iniciar o mapa.\"\"\"\n    if not posicoes.empty:\n        return float(posicoes.iloc[0][\"py\"]), float(posicoes.iloc[0][\"px\"])\n    if not paradas.empty:\n        return float(paradas.iloc[0][\"py\"]), float(paradas.iloc[0][\"px\"])\n    # fallback aproximado\n    return -23.5408, -46.7035\n\n\nlatitude_centro, longitude_centro = obter_centro_mapa(paradas_df, posicoes_df)\nmapa = folium.Map(location=[latitude_centro, longitude_centro], zoom_start=13)\ncamada_paradas = folium.FeatureGroup(name=\"Paradas\").add_to(mapa)\ncamada_posicoes = folium.FeatureGroup(name=\"Veiculos em tempo real\").add_to(mapa)\n\nfor _, parada in paradas_df.iterrows():\n    folium.Marker(\n        location=[parada[\"py\"], parada[\"px\"]],\n        popup=f\"{parada['np']}&lt;br&gt;{parada['ed']}\",\n        icon=folium.Icon(color=\"blue\", icon=\"info-sign\"),\n    ).add_to(camada_paradas)\n\nfor _, veiculo in posicoes_df.iterrows():\n    latitude = veiculo.get(\"py\")\n    longitude = veiculo.get(\"px\")\n    if pd.isna(latitude) or pd.isna(longitude):\n        continue\n    popup_linhas = [\n        f\"Prefixo {veiculo.get('p', 'desconhecido')}\",\n        f\"Sentido: {veiculo.get('sentido', 'nao informado')}\",\n    ]\n    rota_info = veiculo.get(\"rota\", \"\")\n    if isinstance(rota_info, str) and rota_info:\n        popup_linhas.append(f\"Rota: {rota_info}\")\n    ta_valor = veiculo.get(\"ta\")\n    if ta_valor:\n        popup_linhas.append(f\"Atualizado em {ta_valor}\")\n    popup_texto = \"&lt;br&gt;\".join(popup_linhas)\n    folium.Marker(\n        location=[float(latitude), float(longitude)],\n        popup=popup_texto,\n        icon=folium.Icon(color=\"red\", icon=\"bus\", prefix=\"fa\"),\n    ).add_to(camada_posicoes)\n\nfolium.LayerControl().add_to(mapa)\n\ntotal_paradas = len(paradas_df)\nveiculos_em_operacao = len(posicoes_df)\nultima_atualizacao = (\n    posicoes_df[\"ta\"].max() if not posicoes_df.empty else \"sem dados no momento\"\n)\n\n\nParadas (amostra)Veiculos em tempo realMapa interativo\n\n\n\nparadas_resumo.head(10)\n\n\n\n\n\n\n\n\nParada\nEndereco\n\n\n\n\n0\nFREGUESIA B/C\nR CESARE BADIALI/ R ENRICO CARAFA - Rua Giácom...\n\n\n1\nMARGINAL B/C\nAC PONTE DO PIQUERI AV EMB MACEDO SOARES/ R PR...\n\n\n2\nJOSE MARIA B/C\nR BELCHIOR CARNEIRO/ PC SEBASTIAO JAYME PINTO\n\n\n3\nZANELLA B/C\nR NICOLAU PERRONE/ AV ERMANO MARCHETTI\n\n\n4\nGUERINO B/C\nAV MIGUEL DE CASTRO/ R MAL. MENDES DE MORAIS\n\n\n5\nMANOEL BARBOSA B/C\nR DR. FERREIRA DA LUZ/ R DOM MANUEL D ELBOUX\n\n\n6\nCABO ADAO B/C\nR DR. EDUARDO VITOR DE LAMARE/ R CONSTANTINO NERY\n\n\n7\nPRAÇA YARA B/C\nR PRF. BELFORD ROXO/ AV MIGUEL DE CASTRO\n\n\n8\nMIGUEL DE CASTRO\nR STO ALIRIO/ R JOSE ALBANO\n\n\n9\n2 - RIO VERDE B/C\nR CANNER/ R ROBERTO SWICKER JUNIOR\n\n\n\n\n\n\n\n\n\n\nposicoes_resumo\n\n\n\n\n\n\n\n\nPrefixo\nSentido\nRota\nAtualizacao (UTC)\n\n\n\n\n0\n11771\nIda\nTERM. LAPA -&gt; TERM. PIRITUBA\n2025-12-26T07:21:14Z\n\n\n\n\n\n\n\n\n\n\nmapa\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\n\n\n\n\n\n\n\n\n\n\n\n- Paradas cadastradas: 28\n- Veiculos localizados agora: 1\n- Ultima atualizacao reportada: 2025-12-26T07:21:14Z"
  },
  {
    "objectID": "index.html#atividade-3-regressao-linear-por-matriz",
    "href": "index.html#atividade-3-regressao-linear-por-matriz",
    "title": "Blog Individual ( Juan Mendes )",
    "section": "Atividade 3 – Regressao linear por matriz",
    "text": "Atividade 3 – Regressao linear por matriz\n\nObjetivo: estimar y = a + bx usando a forma matricial (X^TX)^{-1}X^Ty e ilustrar a reta encontrada.\nDados: dados_x.txt (anos de estudo) e dados_y.txt (salario mensal).\nFerramentas: numpy, pandas, plotly.graph_objects.\n\n\n\n\n\n\n\nLeitura e ajuste: O script lê os arquivos dados_x.txt e dados_y.txt, monta a matriz X com uma coluna de 1 (intercepto) e outra com os anos de estudo, e aplica a fórmula matricial dos mínimos quadrados beta = (XᵀX)⁻¹ Xᵀ y para obter os coeficientes a (intercepto) e b (inclinação). Em seguida, calcula os resíduos, ss_res, ss_tot e o coeficiente de determinação r2 para quantificar quanto a reta explica a dispersão dos salários observados.\nResultados e visualização: Agrupa os dados em resultado_df com anos de estudo, salários observados e estimados ordenados e arredondados, prepara df_plot e cria fig_atividade3, que combina pontos de dispersão azuis com a reta estimada vermelha. O layout usa título, rótulos de eixo, o tema plotly_white, hover ajustado e legenda horizontal acima do gráfico, entregando uma visualização clara da relação entre educação e salário.\n\n\n\n\nimport numpy as np\nimport pandas as pd\nimport plotly.graph_objects as go\n\nx = np.loadtxt(\"dados_x.txt\", dtype=float)\ny = np.loadtxt(\"dados_y.txt\", dtype=float)\n\nX = np.column_stack([np.ones_like(x), x])\nbeta = np.linalg.inv(X.T @ X) @ X.T @ y\na, b = beta\ny_estimado = a + b * x\n\nresiduos = y - y_estimado\nss_res = np.sum(residuos**2)\nss_tot = np.sum((y - y.mean()) ** 2)\nr2 = 1 - ss_res / ss_tot\n\nresultado_df = (\n    pd.DataFrame(\n        {\n            \"Anos de estudo\": x,\n            \"Salario observado (R$)\": y,\n            \"Salario estimado (R$)\": y_estimado,\n        }\n    )\n    .sort_values(\"Anos de estudo\")\n    .reset_index(drop=True)\n    .round(2)\n)\n\ndf_plot = resultado_df[\n    [\"Anos de estudo\", \"Salario observado (R$)\", \"Salario estimado (R$)\"]\n].copy()\nfig_atividade3 = go.Figure()\nfig_atividade3.add_trace(\n    go.Scatter(\n        x=df_plot[\"Anos de estudo\"],\n        y=df_plot[\"Salario observado (R$)\"],\n        mode=\"markers\",\n        marker=dict(color=\"#1f77b4\", size=8),\n        hovertemplate=\"Anos de estudo: %{x}&lt;br&gt;Salário: R$ %{y:.2f}&lt;extra&gt;&lt;/extra&gt;\",\n        name=\"Salário observado\",\n    )\n)\nfig_atividade3.add_trace(\n    go.Scatter(\n        x=df_plot[\"Anos de estudo\"],\n        y=df_plot[\"Salario estimado (R$)\"],\n        mode=\"lines\",\n        line=dict(color=\"#d62728\", width=3),\n        hoverinfo=\"skip\",\n        name=\"Reta estimada\",\n    )\n)\n_ = fig_atividade3.update_layout(\n    title=\"Relação entre anos de estudo e salário\",\n    xaxis_title=\"Anos de estudo\",\n    yaxis_title=\"Salário (R$)\",\n    template=\"plotly_white\",\n    hovermode=\"closest\",\n    legend=dict(orientation=\"h\", yanchor=\"bottom\", y=1.02, xanchor=\"right\", x=1),\n)\n\n\nTabela comparativaGrafico com reta estimada\n\n\n\nresultado_df\n\n\n\n\n\n\n\n\nAnos de estudo\nSalario observado (R$)\nSalario estimado (R$)\n\n\n\n\n0\n1.00\n1143.98\n1365.68\n\n\n1\n1.02\n2419.26\n1384.39\n\n\n2\n1.02\n1447.13\n1389.05\n\n\n3\n1.02\n334.16\n1389.11\n\n\n4\n1.02\n1214.72\n1389.13\n\n\n...\n...\n...\n...\n\n\n695\n15.80\n16539.95\n16042.26\n\n\n696\n15.80\n17606.52\n16042.30\n\n\n697\n15.83\n14651.59\n16066.79\n\n\n698\n15.94\n16136.22\n16176.73\n\n\n699\n15.94\n16257.79\n16178.58\n\n\n\n\n700 rows × 3 columns\n\n\n\n\n\n\nfig_atividade3\n\n                            \n                                            \n\n\n\n\n\n\n\n\n\n\n\n\n\n**Equacao estimada:** salario = 373.93 + 991.63 x anos de estudo\n**Coeficiente de determinacao (R2):** 0.9427\n\n\n\n\n\n\nA primeira atividade mostra como consultar a série PTAX do dólar diretamente da API do Banco Central, tratar as datas e valores com pandas e gerar um gráfico interativo em Plotly exibindo a variação diária do câmbio. Ela enfatiza o uso de séries temporais reais e a limpeza de dados.\nA segunda atividade apresenta a integração com a API Olho Vivo da SPTrans, obtendo linhas, paradas e posições de veículos em tempo real. Os dados são organizados e exibidos em um mapa interativo no Folium, demonstrando visualização geográfica aplicada.\nA terceira atividade aplica regressão linear para relacionar anos de estudo e salário, usando numpy e pandas para o cálculo e Plotly para criar um gráfico que combina os pontos observados com a reta estimada. As três juntas mostram coleta de dados, tratamento e visualização clara e objetiva."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  }
]